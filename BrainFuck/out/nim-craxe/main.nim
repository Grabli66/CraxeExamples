# Generated by Haxe 4.0.0-rc.2+77068e10c
# Hail to Mighty CRAXE!!!

{.experimental: "codeReordering".}

import nimboot

type 
    Operation = ref object of HaxeEnum

    OperationPrint = ref object of Operation

    OperationMove = ref object of Operation
        v : int

    OperationLoop = ref object of Operation
        v : HaxeArray[Operation]

    OperationInc = ref object of Operation
        v : int


proc newOperationPrint() : OperationPrint {.inline.} =
    OperationPrint(index: 2)

proc `$`(this: OperationPrint) : string {.inline.} =
    result = $this[]

proc `==`(e1:OperationPrint, e2:OperationPrint) : bool {.inline.} =
    result = e1[] == e2[]

proc newOperationMove(v:int) : OperationMove {.inline.} =
    OperationMove(index: 1, v: v)

proc `$`(this: OperationMove) : string {.inline.} =
    result = $this[]

proc `==`(e1:OperationMove, e2:OperationMove) : bool {.inline.} =
    result = e1[] == e2[]

proc newOperationLoop(v:HaxeArray[Operation]) : OperationLoop {.inline.} =
    OperationLoop(index: 3, v: v)

proc `$`(this: OperationLoop) : string {.inline.} =
    result = $this[]

proc `==`(e1:OperationLoop, e2:OperationLoop) : bool {.inline.} =
    result = e1[] == e2[]

proc newOperationInc(v:int) : OperationInc {.inline.} =
    OperationInc(index: 0, v: v)

proc `$`(this: OperationInc) : string {.inline.} =
    result = $this[]

proc `==`(e1:OperationInc, e2:OperationInc) : bool {.inline.} =
    result = e1[] == e2[]

type 
    Tape = ref object of RootObj
        pos : int
        tape : HaxeBytes

    Program = ref object of RootObj
        text : string
        ops : HaxeArray[Operation]
        pos : int

    BrainFuck = ref object of RootObj

    BrainFuckStatic = object of RootObj


let BrainFuckStaticInst = BrainFuckStatic()

proc initTape(this:Tape) {.inline.} =
    this.pos = 0
    this.tape = HaxeBytesStaticInst.alloc(30000)

proc newTape() : Tape {.inline.} =
    result = Tape()
    initTape(result)

proc get(this:Tape) : int =
    return this.tape[this.pos]

proc inc(this:Tape, x:int) : void =
    var b = this.tape[this.pos]
    b += x
    var locthis = this.tape
    var pos = this.pos
    locthis[pos] = b and 255

proc move(this:Tape, x:int) : void =
    this.pos += x
    while this.pos >= this.tape.length:
        this.tape = HaxeBytesStaticInst.alloc(this.tape.length * 2)

proc `$`(this:Tape) : string {.inline.} = 
    result = "Tape" & $this[]

proc initProgram(this:Program, text:string) {.inline.} =
    this.pos = 0
    this.text = text
    this.ops = this.parse()

proc newProgram(text:string) : Program {.inline.} =
    result = Program()
    initProgram(result, text)

proc parse(this:Program) : HaxeArray[Operation] =
    var res = newHaxeArray[Operation]()
    while this.pos < this.text.length:
        var c = this.text.charAt(this.pos)
        this.pos += 1
        if c == "+":
            res.push(newOperationInc(1))
        elif c == "-":
            res.push(newOperationInc(-1))
        elif c == ".":
            res.push(newOperationPrint())
        elif c == "<":
            res.push(newOperationMove(-1))
        elif c == ">":
            res.push(newOperationMove(1))
        elif c == "[":
            res.push(newOperationLoop(this.parse()))
        elif c == "]":
            return res

    return res

proc runInternal(this:Program, operations:HaxeArray[Operation], tape:Tape) : void =
    var locg = 0
    while locg < operations.length:
        var op = operations[locg]
        bpOperator(locg)
        if op == 0:
            var v = cast[OperationInc](op).v
            var b = tape.tape[tape.pos]
            b += v
            var locthis = tape.tape
            var pos = tape.pos
            locthis[pos] = b and 255
        elif op == 1:
            var v1 = cast[OperationMove](op).v
            tape.pos += v1
            while tape.pos >= tape.tape.length:
                tape.tape = HaxeBytesStaticInst.alloc(tape.tape.length * 2)
        elif op == 2:
            LogStaticInst.trace(tape.tape[tape.pos], "src/BrainFuck.hx", 79, "Program", "runInternal")
        elif op == 3:
            var v2 = cast[OperationLoop](op).v
            while tape.tape[tape.pos] > 0:
                this.runInternal(v2, tape)


proc run(this:Program) : void =
    this.runInternal(this.ops, newTape())

proc `$`(this:Program) : string {.inline.} = 
    result = "Program" & $this[]

proc main(this:BrainFuckStatic) : void =
    var text = FileStaticInst.getContent("code.b")
    var program = newProgram(text)
    program.run()

proc `$`(this:BrainFuck) : string {.inline.} = 
    result = "BrainFuck" & $this[]

BrainFuckStaticInst.main()