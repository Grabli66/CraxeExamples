# Generated by Haxe 4.0.0-rc.3+e3df7a448
# Hail to Mighty CRAXE!!!

{.experimental: "codeReordering".}

import craxecore

type 
    Operation = ref object of HaxeEnum

    OperationPrint = ref object of Operation
    OperationMove = ref object of Operation
        v : int

    OperationLoop = ref object of Operation
        v : HaxeArray[Operation]

    OperationInc = ref object of Operation
        v : int


proc newOperationPrint() : OperationPrint {.inline.} =
    OperationPrint(index: 2)

proc `$`(this: OperationPrint) : string {.inline.} =
    result = $this[]

proc `==`(e1:OperationPrint, e2:OperationPrint) : bool {.inline.} =
    result = e1[] == e2[]

proc newOperationMove(v:int) : OperationMove {.inline.} =
    OperationMove(index: 1, v: v)

proc `$`(this: OperationMove) : string {.inline.} =
    result = $this[]

proc `==`(e1:OperationMove, e2:OperationMove) : bool {.inline.} =
    result = e1[] == e2[]

proc newOperationLoop(v:HaxeArray[Operation]) : OperationLoop {.inline.} =
    OperationLoop(index: 3, v: v)

proc `$`(this: OperationLoop) : string {.inline.} =
    result = $this[]

proc `==`(e1:OperationLoop, e2:OperationLoop) : bool {.inline.} =
    result = e1[] == e2[]

proc newOperationInc(v:int) : OperationInc {.inline.} =
    OperationInc(index: 0, v: v)

proc `$`(this: OperationInc) : string {.inline.} =
    result = $this[]

proc `==`(e1:OperationInc, e2:OperationInc) : bool {.inline.} =
    result = e1[] == e2[]

### Classes and structures
type 
    Tape = ref object of HaxeObject
        pos : int
        tape : HaxeBytes

    Program = ref object of HaxeObject
        text : string
        ops : HaxeArray[Operation]
        pos : int

    BrainFuck = ref object of HaxeObject

    BrainFuckStatic = object of HaxeObject

let BrainFuckStaticInst = BrainFuckStatic()

proc initTape(this:Tape) {.inline.} =
    this.pos = 0
    this.tape = HaxeBytesStaticInst.alloc(30000)

proc newTape() : Tape {.inline.} =
    var this = Tape()
    initTape(this)
    return this

proc initProgram(this:Program, text:string) {.inline.} =
    this.pos = 0
    this.text = text
    this.ops = this.parse()

proc newProgram(text:string) : Program {.inline.} =
    var this = Program()
    initProgram(this, text)
    return this

proc get(this:Tape) : int =
    return this.tape[this.pos]

proc inc(this:Tape, x:int) : void =
    var b = this.tape[this.pos]
    b += x
    var locthis = this.tape
    var pos = this.pos
    locthis[pos] = b and 255

proc move(this:Tape, x:int) : void =
    this.pos += x
    while this.pos >= this.tape.length:
        this.tape = HaxeBytesStaticInst.alloc(this.tape.length * 2)

proc `$`(this:Tape) : string {.inline.} = 
    result = "Tape" & $this[]

proc parse(this:Program) : HaxeArray[Operation] =
    var res = newHaxeArray[Operation]()
    while this.pos < this.text.length:
        var c = this.text.charAt(this.pos)
        this.pos += 1
        case c
        of "+":
            discard res.push(newOperationInc(1))
        of "-":
            discard res.push(newOperationInc(-1))
        of ".":
            discard res.push(newOperationPrint())
        of "<":
            discard res.push(newOperationMove(-1))
        of ">":
            discard res.push(newOperationMove(1))
        of "[":
            discard res.push(newOperationLoop(this.parse()))
        of "]":
            return res
        else:
            raise newException(Exception, "Invalid case")

    return res

proc runInternal(this:Program, operations:HaxeArray[Operation], tape:Tape) : void =
    var locg = 0
    while locg < operations.length:
        var op = operations[locg]
        bpOperator(locg)
        case op.index
        of 0:
            var locg2 = cast[OperationInc](op).v
            var v = locg2
            var b = tape.tape[tape.pos]
            b += v
            var locthis = tape.tape
            var pos = tape.pos
            locthis[pos] = b and 255
        of 1:
            var locg1 = cast[OperationMove](op).v
            var v1 = locg1
            tape.pos += v1
            while tape.pos >= tape.tape.length:
                tape.tape = HaxeBytesStaticInst.alloc(tape.tape.length * 2)
        of 2:
            LogStaticInst.trace(tape.tape[tape.pos], "src/BrainFuck.hx", 79, "Program", "runInternal")
        of 3:
            var locg11 = cast[OperationLoop](op).v
            var v2 = locg11
            while tape.tape[tape.pos] > 0:
                this.runInternal(v2, tape)
        else:
            raise newException(Exception, "Invalid case")


proc run(this:Program) : void =
    this.runInternal(this.ops, newTape())

proc `$`(this:Program) : string {.inline.} = 
    result = "Program" & $this[]

proc main(this:BrainFuckStatic) : void =
    var text = FileStaticInst.getContent("code.b")
    var program = newProgram(text)
    program.run()

proc `$`(this:BrainFuck) : string {.inline.} = 
    result = "BrainFuck" & $this[]


BrainFuckStaticInst.main()